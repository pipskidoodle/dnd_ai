"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenAI = void 0;
const axios_1 = require("axios");
const lodash_1 = require("lodash");
const openai_1 = require("openai");
const chat_1 = require("../chat");
const config_1 = require("../config");
const utils_1 = require("../utils");
const Defaults = { model: 'gpt-3.5-turbo', messages: [] };
const convertConfig = (config) => ({
    model: config.model,
    temperature: config.temperature,
    top_p: config.topP,
    n: 1,
    stop: config.stop,
    presence_penalty: config.presencePenalty,
    frequency_penalty: config.frequencyPenalty,
    logit_bias: config.logitBias,
    user: config.user,
});
class OpenAI {
    openai;
    defaults;
    constructor(config, defaults) {
        const configuration = new openai_1.Configuration({ apiKey: config.apiKey });
        this.openai = new openai_1.OpenAIApi(configuration);
        this.defaults = defaults ?? {};
    }
    chat(persona, config) {
        return new chat_1.Chat(persona, config ?? {}, this);
    }
    async request(messages, config = {}, { retries = config_1.CompletionDefaultRetries, retryInterval = config_1.RateLimitRetryIntervalMs, timeout = config_1.CompletionDefaultTimeout, ...opt } = {}) {
        const finalConfig = (0, lodash_1.defaults)(convertConfig(config), convertConfig(this.defaults), Defaults);
        utils_1.debug.log(`Sending request with ${retries} retries, config: ${JSON.stringify(finalConfig)}`);
        try {
            const completion = await this.openai.createChatCompletion({
                ...finalConfig,
                messages,
            }, { timeout });
            const content = completion.data.choices[0].message?.content;
            const usage = completion.data.usage;
            if (!content || !usage) {
                throw new Error('Completion response malformed');
            }
            return {
                content,
                model: completion.data.model,
                usage: {
                    totalTokens: usage.total_tokens,
                    promptTokens: usage.prompt_tokens,
                    completionTokens: usage.completion_tokens,
                },
            };
        }
        catch (error) {
            if (!(0, axios_1.isAxiosError)(error)) {
                throw error;
            }
            if (!retries) {
                utils_1.debug.log('Completion failed, already retryed, failing completion');
                throw error;
            }
            if (error.code === 'ETIMEDOUT' ||
                error.code === 'ECONNABORTED' ||
                error.code === 'ECONNRESET' ||
                (error.response && (error.response.status === 429 || error.response.status >= 500))) {
                utils_1.debug.log(`Completion rate limited, retrying... attempts left: ${retries}`);
                await (0, utils_1.sleep)(retryInterval);
                return this.request(messages, config, {
                    ...opt,
                    retries: retries - 1,
                    retryInterval: retryInterval * 2,
                });
            }
            if (error?.response?.status === 401) {
                utils_1.debug.error('Authorization error, did you set the OpenAI API key correctly?');
            }
            throw error;
        }
    }
}
exports.OpenAI = OpenAI;
